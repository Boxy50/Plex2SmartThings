/**
 *  Plex Plus Child
 *
 *  Copyright 2015 Christian Hjelseth / Jake Tebbett
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 * 
 * VERSION CONTROL - Plex Plus Child
 * ###############
 *
 *  v2.0 - Modified Christian Hjelseth's excellent Smart App to use parent & child apps
 * 				- Allowing multi room matching to a single player
 * 				- Allowing flexible number of "rooms"
 * 		 - Added support for matching against Player Name or User Name or IP Address (IP address requires Jake's modified exe)
 *		 - Added support for on and off switches on the same state change.
 *		 - Added disabled switch to stop automation
 *	v2.1 - Removed independant debug logging from child app, now mastered from parent.
 *		 - Fix bug with disable switch
 *		 - Added Hue Colors (First select Hues)
 *  v2.2 - Changes to order of items in App
 *		 - Added momentary switch, better for triggering scenes in other apps (doesn't trigger a second time on toggle off)
 *  v2.3 - Cosmetic changes including hiding dimmer settings when no dimmers selected.
 *  v2.4 - Added the ability to return switches to the state before Plex started playing.
 *  v2.5 - Updated icon path
 *  v2.6 - 02/05/16 - Added MusicPlayer device handler support for Plex HT SmartApp support, fixed some bugs, made code more efficient.
 *  v2.7 - 05/05/16 - Further code efficiencies and also added support for trailers with Plex media device type.
 *  v2.8 - 02/07/16 - Removed routine handling, due to errors on some android devices. Added running only in selected modes.
 */



definition(
    name: "Plex Plus Child",
    namespace: "jebbett",
    author: "Christian Hjelseth & Jacob Tebbett",
    description: "Allows web requests to dim/turn off/on lights when plex is playing",
    category: "My Apps",
    parent: "jebbett:Plex Plus",
    iconUrl: "https://raw.githubusercontent.com/jebbett/Plex2SmartThings/PlexPlus/icon.png",
    iconX2Url: "https://raw.githubusercontent.com/jebbett/Plex2SmartThings/PlexPlus/icon.png",
    iconX3Url: "https://raw.githubusercontent.com/jebbett/Plex2SmartThings/PlexPlus/icon.png")


preferences {
    page name: "mainPage", install: false, uninstall: true
}

def installed() {
    log.debug "Installed with settings: ${settings}"
    initialize()
}

def updated() {
    log.debug "Updated with settings: ${settings}"
    unschedule()
    initialize()
}

def initialize() {
	unsubscribe()
	state.catcherRunning = false
    subscribe(playerDT, "status", PlayerDTCommandRecieved)
}

// Main page to select room settings
def mainPage() {
        
    dynamicPage(name: "mainPage", uninstall: true, install: true) {
        
        section() {
                label title: "Enter Room Name", defaultValue: app.label, required: false
        }
		
		//ROOM
		section("Players") {
            input(name: "playerA1", type: "text", title: "Player name, User or IP", required:false)
            input(name: "playerB1", type: "text", title: "Player name, User or IP (alternative)", required:false)
            input(name: "playerDT", type: "capability.musicPlayer", title: "ST Media Player Device", multiple: false, required:false)
            paragraph "To identify player, you can use either Player Device Name, Username, IP address or * in order to match any player where using the Plex2SmartThings program on your computer or you can use a supported media player device type."
        }
		section("Lights (Hue bulbs have color)") {
			input "dimmers1", "capability.switchLevel", title: "Dimmers", multiple: true, required: false, submitOnChange: true
            input "hues1", "capability.colorControl", title: "Hue Bulbs", multiple:true, required:false, submitOnChange: true
            if(hues1||dimmers1) {
            input(name: "iLevelOnPlay1", type: "number", title: "Level on Play", defaultValue:0)
            input(name: "iLevelOnPause1", type: "number", title: "Level on Pause", defaultValue:30)
            input(name: "iLevelOnStop1", type: "number", title: "Level on Stop", defaultValue:100)
            }
            if(hues1) {
				input "colorOnPlay", "enum", title: "Hue Bulbs > Color On Play", required: false, multiple: false, submitOnChange: true,
					options: ["Soft White", "White", "Daylight", "Warm White", "Red", "Green", "Blue", "Yellow", "Orange", "Purple", "Pink"]
                input "colorOnPause", "enum", title: "Hue Bulbs > Color On Pause", required: false, multiple: false, submitOnChange: true,
					options: ["Soft White", "White", "Daylight", "Warm White", "Red", "Green", "Blue", "Yellow", "Orange", "Purple", "Pink"]
                input "colorOnStop", "enum", title: "Hue Bulbs > Color On Stop", required: false, multiple: false, submitOnChange: true,
					options: ["Soft White", "White", "Daylight", "Warm White", "Red", "Green", "Blue", "Yellow", "Orange", "Purple", "Pink"]
            }
            input(name: "bDimOnlyIfOn1", type: "bool", title: "Dim bulbs only if they're already on")
        }
		section("Switches") {
        	input "switches2", "capability.switch", title:"Switches On when Playing", multiple: true, required: false
            input "switches1", "capability.switch", title:"Switches Off when Playing", multiple: true, required: false
            input(name: "bReturnState1", type: "bool", title: "Switches return to original state when Stopped")
            input(name: "bSwitchOffOnPause1", type: "bool", title: "Switches use Play config when Paused")
            paragraph "The below switches do not toggle off when state becomes inactive, ideal for tiggering external App scenes"
            input "mSwitchPlay", "capability.switch", title:"Momentary switch on Play", multiple: true, required: false
            input "mSwitchPause", "capability.switch", title:"Momentary switch on Pause", multiple: true, required: false
            input "mSwitchStop", "capability.switch", title:"Momentary switch on Stop", multiple: true, required: false
           
            
        }
		section("Modes") {
			input "playMode1", "mode", title: "Mode when playing", required:false
			input "pauseMode1", "mode", title: "Mode when paused", required:false
			input "stopMode1", "mode", title: "Mode when stopped", required:false
		}
		section("Settings") {
			input(name: "bTreatTrailersAsPause1", type: "bool", title: "Use pause config for movie trailers")
            input "disabled", "capability.switch", title: "Switch to disable when On", required: false, multiple: false
            input "activeMode", "mode", title: "Only run in selected modes", multiple: true, required:false
		}
    }
}

// Recieve command from MusicPlayer device type

def PlayerDTCommandRecieved(evt){
	
	//If no device type configured do not run the below code
	if(!playerDT){return}
    
	if(evt.value=="playing"){AppCommandRecieved("onplay", "Unknown", playerDT,"ST Media Player Device", playerDT.currentplaybackType)}
	else if(evt.value=="stopped"){AppCommandRecieved("onstop", "Unknown", playerDT,"ST Media Player Device", playerDT.currentplaybackType)}
    else if(evt.value=="paused"){AppCommandRecieved("onpause", "Unknown", playerDT,"ST Media Player Device", playerDT.currentplaybackType)}
    
}


// Recieve command from parent app

def AppCommandRecieved(command, userName, playerName, playerIP, mediaType) {

//Log last event
	parent.StoreLastEvent(command, userName, playerName, playerIP, mediaType)

//Check if room found
	def roomFound = findAMatch(playerName, playerIP, userName)
    
// Exit if no room found
	if(roomFound == -1) {logWriterChild ("->No match found for room: ${app.label}"); return}
    logWriterChild ("->Match found for room: ${app.label}")
    
// Stop running if disable switch is activated    

    if (disabled != null) {if(disabled.currentSwitch == "on") {logWriterChild ("->Disabled via switch"); return}}
    if (activeMode != null && !activeMode.contains(location.mode)) {logWriterChild ("->Disabled via invalid mode"); return}
    
//Translate play to pause if bTreatTrailersAsPause is enabled for this room
    if(bTreatTrailersAsPause1 && mediaType == "clip" && command == "onplay") {command = "onpause"}


// Play, Pause or Stop

    if (command == "onplay") {
    	logWriterChild ("->Playing")
        if(!state.catcherRunning){
        	catchState("switches1")
    		catchState("switches2")
            state.catcherRunning = true
        }
        ChangeMode(playMode1)
		SetLevels(iLevelOnPlay1, colorOnPlay)
        SetSwitchesOff()
        mSwitchPlay?.on()
    }
    else if (command == "onpause") {        
        logWriterChild ("->Paused")
        ChangeMode(pauseMode1)
    	SetLevels(iLevelOnPause1, colorOnPause)
        mSwitchPause?.on()
        if(bSwitchOffOnPause1) {
       		SetSwitchesOff()
        } else {
        	if(state.catcherRunning && bReturnState1){
        		returnToState("switches1")
    			returnToState("switches2")
            	state.catcherRunning = false
        	}else{
        		SetSwitchesOn()
            	state.catcherRunning = false
        	}
        }
    }
    else if (command == "onstop") {
        logWriterChild ("->Stopped")
        ChangeMode(stopMode1)
    	SetLevels(iLevelOnStop1, colorOnStop)
        mSwitchStop?.on()
        if(state.catcherRunning && bReturnState1){
        	returnToState("switches1")
    		returnToState("switches2")
            state.catcherRunning = false
        }else{
        	SetSwitchesOn()
            state.catcherRunning = false
        }
    }
}

// Actions

def ChangeMode(newMode) {
    if (newMode != null && newMode != "" && location.mode != newMode) {
        if (location.modes?.find{it.name == newMode}) {setLocationMode(newMode)}
        else {log.warn "Tried to change to undefined mode '${newMode}'"}
    }
}

def SetSwitchesOn() {
	switches1?.on()
    switches2?.off()
}
def SetSwitchesOff() {
	switches1?.off()
    switches2?.on()
}


def SetLevels(level, acolor) {
	// If color specified set hues
    if (level != null) {        
    	def hueColor = 23
		def saturation = 56
		switch(acolor) {
			case "White":
				hueColor = 52
				saturation = 19
				break;
			case "Daylight":
				hueColor = 53
				saturation = 91
				break;
			case "Soft White":
				hueColor = 23
				saturation = 56
				break;
			case "Warm White":
				hueColor = 20
				saturation = 80 //83
				break;
			case "Blue":
				hueColor = 70
				break;
			case "Green":
				hueColor = 35
				break;
			case "Yellow":
				hueColor = 25
				break;
			case "Orange":
				hueColor = 10
				break;
			case "Purple":
				hueColor = 75
				break;
			case "Pink":
				hueColor = 83
				break;
			case "Red":
				hueColor = 100
				break;
		}
        
        if (bDimOnlyIfOn1){
        	hues1?.each { hue -> if ("on" == hue.currentSwitch) {hue.setColor([hue: hueColor, saturation: saturation, level: level])}}
        	dimmers1?.each { bulb -> if ("on" == bulb.currentSwitch) {bulb.setLevel(level)}}
        }else{
        	hues1?.setColor([hue: hueColor, saturation: saturation, level: level])
            dimmers1?.setLevel(level)
        }
	}
}

//Save state
private catchState(switches) {
        settings."${switches}"?.each { switcher -> state."${switcher.id}State" = switcher.currentValue("switch")
        	logWriterChild (switcher.currentValue("switch"))
        }
}
//Return to state
private returnToState(switches) {
	settings."${switches}"?.each {switcher -> 
    	if(state."${switcher.id}State" == "on") {switcher.on()}
        if(state."${switcher.id}State" == "off") {switcher.off()}
    }
}

// Debug logging

private def logWriterChild(value) {	
    parent.logWriter (value)
}


//Is the player, IP or user found
def findAMatch(player, IP, user) {
    if(playerA1 == "*" || playerB1 == "*" || playerA1 == player || playerB1 == player || playerA1 == IP || playerB1 == IP || playerA1 == user || playerB1 == user || IP == "ST Media Player Device") return 1;
    else return -1;
}